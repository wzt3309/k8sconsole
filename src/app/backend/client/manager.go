package client

import (
	"crypto/rand"
	"errors"
	"github.com/emicklei/go-restful"
	"github.com/golang/glog"
	authApi "github.com/wzt3309/k8sconsole/src/app/backend/auth/api"
	clientApi "github.com/wzt3309/k8sconsole/src/app/backend/client/api"
	"k8s.io/api/authorization/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/tools/clientcmd/api"
	"strings"
)

const (
	// High enough QPS to fit all expected use cases.
	DefaultQPS = 1e6
	// High enough Burst to fit all expected use cases.
	DefaultBurst = 1e6
	// Use kubernetes protobuf as content type by default to communicate with apiserver
	DefaultContentType = "application/vnd.kubernetes.protobuf"
	// Default http header for user-agent
	DefaultUserAgent = "k8sconsole"

	// Default cluster/context/auth name to be set in clientcmd config
	DefaultCmdConfigName = "kubernetes"

	// Header name that contains token used for authorization.
	JWETokenHeader = "jweToken"
)

// Implements ClientManager interface.
type clientManager struct {
	// Autogenerated key on backend to prevent request from csrf attacks
	csrfKey string
	// Path to kubeconfig file. If both kubeConfigPath and apiserverHost are empty inClusterConfig will be used
	kubeConfigPath string
	// Address of apiserver host in format 'protocol://address:port'
	apiserverHost string
	// Initialized on clientManger creation and used if kubeConfigPath and apiserverHost are empty
	inClusterConfig *rest.Config
	// Responsible for decrypting tokens coming in request header. Used for authentication
	tokenManager authApi.TokenManager
	// K8s client created without providing auth info. It uses permissions granted to service account used by
	// k8sconsole or kubeconfig file if it was passed during k8sconsole init
	insecureClient kubernetes.Interface
}

// Client returns client to connect to k8s apiserver
func (self *clientManager) Client(req *restful.Request) (kubernetes.Interface, error) {
	cfg, err := self.Config(req)
	if err != nil {
		return nil, err
	}

	client, err := kubernetes.NewForConfig(cfg)
	if err != nil {
		return nil, err
	}

	return client, nil
}

// InsecureClient returns kubernetes client that was created without providing auth info. It uses permissions granted
// to service account used by dashboard or kubeconfig file if it was passed during k8sconsole init.
func (self *clientManager) InsecureClient() kubernetes.Interface {
	return self.insecureClient
}

// CanI returns whether user is allowed to access data provided with SelfSubjectAccessReview
func (self *clientManager) CanI(req *restful.Request, sar *v1.SelfSubjectAccessReview) bool {
	// If user is not authenticated, do not allow to access
	if info, _ := self.extractAuthInfo(req); info == nil {
		return false
	}

	client, err := self.Client(req)
	if err != nil {
		glog.Error(err)
		return false
	}

	response, err := client.AuthorizationV1().SelfSubjectAccessReviews().Create(sar)
	if err != nil {
		glog.Error(err)
		return false
	}

	return response.Status.Allowed
}

// Config create rest config
func (self *clientManager) Config(req *restful.Request) (*rest.Config, error) {
	cmdConfig, err := self.ClientCmdConfig(req)
	if err != nil {
		return nil, err
	}

	cfg, err := cmdConfig.ClientConfig()
	if err != nil {
		return nil, err
	}

	self.initConfig(cfg)
	return cfg, nil
}

// ClientCmdConfig creates clientcmd config used to create k8s apiserver client
func (self *clientManager) ClientCmdConfig(req *restful.Request) (clientcmd.ClientConfig, error) {
	authInfo, err := self.extractAuthInfo(req)
	if err != nil {
		return nil, err
	}

	cfg, err := self.buildConfigFromFlags(self.kubeConfigPath, self.apiserverHost)
	if err != nil {
		return nil, err
	}

	// Use auth data provided in cfg if extracted auth is nil
	if authInfo == nil {
		defaultAuthInfo := self.buildAuthInfoFromConfig(cfg)
		authInfo = &defaultAuthInfo
	}

	return self.buildCmdConfig(authInfo, cfg), nil
}

// CSRFKey returns key generated upon client manager creation
func (self *clientManager) CSRFKey() string {
	return self.csrfKey
}

// HasAccess checks the user with auth info is valid to access the k8s api server
func (self *clientManager) HasAccess(authInfo api.AuthInfo) error {
	cfg, err := self.buildConfigFromFlags(self.kubeConfigPath, self.apiserverHost)
	if err != nil {
		return err
	}

	clientConfig := self.buildCmdConfig(&authInfo, cfg)
	cfg, err = clientConfig.ClientConfig()
	if err != nil {
		return err
	}

	client, err := kubernetes.NewForConfig(cfg)
	if err != nil {
		return err
	}

	_, err = client.ServerVersion()
	return err
}

// VerberClient returns new verber client
func (self *clientManager) VerberClient(req *restful.Request) (clientApi.ResourceVerber, error) {
	client, err := self.Client(req)
	if err != nil {
		return nil, err
	}

	return NewResourceVerber(client.CoreV1().RESTClient(),
		client.ExtensionsV1beta1().RESTClient()), nil
}

// SetTokenManager sets the token manager that will be used for token decryption.
func (self *clientManager) SetTokenManager(manager authApi.TokenManager) {
	self.tokenManager = manager
}

func (self *clientManager) initConfig(cfg *rest.Config) {
	cfg.QPS = DefaultQPS
	cfg.Burst = DefaultBurst
	cfg.ContentType = DefaultContentType
	cfg.UserAgent = DefaultUserAgent
}

// Returns rest config based on provided kubeConfigPath or apiserverHost flags. If both are empty
// then in-cluster config will be used and if it is nil the error is returned.
func (self *clientManager) buildConfigFromFlags(kubeConfigPath, apiserverHost string) (*rest.Config, error) {
	if len(kubeConfigPath) > 0 || len(apiserverHost) > 0 {
		return clientcmd.NewNonInteractiveDeferredLoadingClientConfig(
			&clientcmd.ClientConfigLoadingRules{ExplicitPath: kubeConfigPath},
			&clientcmd.ConfigOverrides{ClusterInfo: api.Cluster{Server: apiserverHost}}).ClientConfig()
	}

	if self.isRunningInCluster() {
		return self.inClusterConfig, nil
	}

	return nil, errors.New("Could not create client config.")
}

// Based on config creates auth info.
func (self *clientManager) buildAuthInfoFromConfig(cfg *rest.Config) api.AuthInfo {
	return api.AuthInfo{
		Token:                 cfg.BearerToken,
		ClientCertificate:     cfg.CertFile,
		ClientKey:             cfg.KeyFile,
		ClientCertificateData: cfg.CertData,
		ClientKeyData:         cfg.KeyData,
		Username:              cfg.Username,
		Password:              cfg.Password,
	}
}

// Based on auth info and rest config to create client cmd config.
func (self *clientManager) buildCmdConfig(authInfo *api.AuthInfo, cfg *rest.Config) clientcmd.ClientConfig {
	cmdCfg := api.NewConfig()

	cmdCfg.Clusters[DefaultCmdConfigName] = &api.Cluster{
		Server:                   cfg.Host,
		CertificateAuthority:     cfg.TLSClientConfig.CAFile,
		CertificateAuthorityData: cfg.TLSClientConfig.CAData,
		InsecureSkipTLSVerify:    cfg.TLSClientConfig.Insecure,
	}

	cmdCfg.AuthInfos[DefaultCmdConfigName] = authInfo

	cmdCfg.Contexts[DefaultCmdConfigName] = &api.Context{
		Cluster:  DefaultCmdConfigName,
		AuthInfo: DefaultCmdConfigName,
	}

	cmdCfg.CurrentContext = DefaultCmdConfigName

	return clientcmd.NewDefaultClientConfig(
		*cmdCfg,
		&clientcmd.ConfigOverrides{})
}

// Extracts authorization information from request head
func (self *clientManager) extractAuthInfo(req *restful.Request) (*api.AuthInfo, error) {
	if req == nil {
		glog.Warning("No request provided. Skipping authorization")
		return nil, nil
	}

	authHeader := req.HeaderParameter("Authorization")
	jweToken := req.HeaderParameter(JWETokenHeader)

	// Authorization header will be more important than our jwe token
	token := self.extractTokenFromHeader(authHeader)
	if len(token) > 0 {
		return &api.AuthInfo{Token: token}, nil
	}

	if self.tokenManager != nil && len(jweToken) > 0 {
		return self.tokenManager.Decrypt(jweToken)
	}

	return nil, nil
}

func (self *clientManager) extractTokenFromHeader(authHeader string) string {
	if strings.HasPrefix(authHeader, "Bearer ") {
		return strings.TrimPrefix(authHeader, "Bearer ")
	}

	return ""
}

func (self *clientManager) init() {
	self.initInClusterConfig()
	self.initCSRFKey()
	self.initInsecureClient()
}

// Initialize in-cluster config if kubeConfigPath and apiserverHost are empty
func (self *clientManager) initInClusterConfig() {
	if len(self.kubeConfigPath) > 0 || len(self.apiserverHost) > 0 {
		glog.Info("Skipping in-cluster config")
		return
	}

	glog.Info("Using in-cluster config to connect to apiserver")
	cfg, err := rest.InClusterConfig()
	if err != nil {
		glog.Errorf("Could not init in cluster config: %s", err.Error())
		return
	}

	self.inClusterConfig = cfg
}

// Initializes csrfKey. If in-cluster config is detected then the csrf key is initialized with
// service account token, otherwise it is generated.
func (self *clientManager) initCSRFKey() {
	if self.inClusterConfig == nil {
		glog.Info("Using random key for csrf signing")
		self.generateCSRFKey()
		return
	}

	glog.Info("Using service account token for csrf signing")
	self.csrfKey = self.inClusterConfig.BearerToken
}

func (self *clientManager) initInsecureClient() {
	insecureClient, err := self.Client(nil)
	if err != nil {
		panic(err)
	}

	self.insecureClient = insecureClient
}

// Generates random csrf key.
func (self *clientManager) generateCSRFKey() {
	bytes := make([]byte, 256)
	_, err := rand.Read(bytes)
	if err != nil {
		panic("Fatal error. Could not generate csrf key")
	}

	self.csrfKey = string(bytes)
}

// Returns true if in-cluster config is used
func (self *clientManager) isRunningInCluster() bool {
	return self.inClusterConfig != nil
}

// NewClientManager creates client manager based on kubeConfigPath and apiserverHost parameters.
// If both are empty then in-cluster config is used.
func NewClientManager(kubeConfigPath, apiserverHost string) clientApi.ClientManager {
	result := &clientManager{
		kubeConfigPath: kubeConfigPath,
		apiserverHost:  apiserverHost,
	}

	result.init()
	return result
}
